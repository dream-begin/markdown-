# 第一章 计算机系统概述

## 1.认识计组

### 1.1 计算机硬件

![image-20240120151138347](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240120151138347.png)

<span style="background:#66FFFF;"> ps：计组相当于计算机的硬件 </span>



![image-20240120151511828](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240120151511828.png)

CPU 的这些小刺叫 <span style="color:#FF0000; font-size:1.3em;"> 针脚 </span>







![image-20240120151649213](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240120151649213.png)

![image-20240120151808311](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240120151808311.png)

### 1.2 计算机硬件能识别的数据



计算机硬件唯一能识别的数据——二进制 0 和 1



用低电平和高电平来表示 0 和 1





### 1.3 什么是低电平高电平

![image-20240120152551796](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240120152551796.png)

用低电压就是低电平，高电压就是高电平

同过 CPU、内存条上的针脚或电路板上的电路就可以传输电流，也就是二进制的 0 和 1



## 2.计算机的发展

![image-20240120153237395](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240120153237395.png)

### 2.1 什么是计算机系统

![image-20240120153534967](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240120153534967.png)

<span style="font-weight:bold;"> 计算机系统 = 硬件+软件 </span>







![image-20240120153752987](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240120153752987.png)

<span style="font-weight:bold;"> 软件还可以分为系统软件和应用软件，操作系统就属于系统软件 </span>





### 2.2 硬件的发展

![image-20240120154153212](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240120154153212.png)



<span style="font-weight:bold;"> 这台计算机需要 1.8 万个电子管（逻辑元件）组合在一起，这就造成了他占地面积大，耗电量惊人，但计算量反而不是很出色 </span>



<span style="font-weight:bold;"> 这个时代我们称为 <span style="color:#FF0000;"> 电子管时代 </span> </span>



**冯诺伊曼作为这台计算机项目的顾问**





![image-20240120154626214](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240120154626214.png)





<span style="font-weight:bold;"> 贝尔实验室发明晶体管后，由于晶体管体积远小于电子管，于是计算机的体积和计算量得到巨大的飞跃，这个阶段我们称为 <span style="color:#FF0000;"> 晶体管时代 </span> </span>

出现面向过程的编程语言：FORTRAN

有了操作系统雏形



![image-20240120155408260](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240120155408260.png)





<span style="font-weight:bold;"> 晶体管的使用并没有改变计算机臃肿的形态，几十万个晶体管就需要至少上百万个焊接点，其中之一出错，就会导致计算机故障，于是随着集成电路技术的出现，大大改善了这个问题，计算机也步入了第三个阶段 <span style="color:#FF0000;"> 中小规模集成电路时代 </span> </span>

高级语言快速发展

出现分时操作系统

但此时计算机的主要用途还是用于专业的科学计算，没有步入个人的使用

![image-20240120160004792](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240120160004792.png)









**随着集成电路的快速发展，于是计算机也进入了第四代 <span style="color:#FF0000;"> 大规模、超大规模集成电路时代 </span>**

此时开始出现微处理器(cpu)，微型计算机（笔记本电脑），个人计算机萌芽

现在的苹果 A13 芯片里每个晶体管的直径做到了每个只有 7nm，所以一个芯片里可以有 85 亿个晶体管

一些操作系统也在此时代诞生（windows、linux 等）

![image-20240129122313382](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240129122313382.png)

![image-20240129140335353](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240129140335353.png)

![image-20240129140707379](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240129140707379.png)

#### 摩尔定律

![image-20240129141014595](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240129141014595.png)





<span style="background:#00FFFF;"> 由摩尔提出表示信息技术发展的速度，比如我花 2000 块买一个 cpu，那么过了 18 个月我就可以同样用 2000 块买个性能翻一倍的 cpu </span>



### 2.3 软件的发展



<span style="background:#33FFFF;"> 对于软件，编程语言的发展就直接影响到了软件的丰富程度 </span>



![image-20240129142125454](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240129142125454.png)

### 2.4 目前的发展趋势

![image-20240129142521783](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240129142521783.png)

一种是更微型、另一种是更巨型

### 小节回顾

![image-20240129142652629](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240129142652629.png)











## 3.计算机硬件的基本组成

![image-20240130131649675](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240130131649675.png)

### 3.1 早期冯诺依曼机

![image-20240130132409910](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240130132409910.png)

**第一台计算机 ENIAC 虽然计算速度比较快，但是它需要操作员通过手动接线的方式来给计算机传达指令，缓慢的人工操作使得 ENIAC 的计算速度大大下降，此时冯诺依曼作为第一台计算机 ENIAC 的顾问，首次提出了 <span style="color:#000000; background:#FFFF00;">“存储程序 </span>”的概念，于是第一台采用冯诺依曼结构的计算机 EDVAC 就出现了**



”存储程序”：是指 <span style="background:#00FFFF;"> 将指令以二进制代码的形式事先输入计算机的主存储器 </span>，然后按其在存储器里的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束

存储程序 71 · 54 使得计算机可以自动化进行指令运算





![image-20240228151737820](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240228151737820.png)



<span style="background:#00FFFF;"> 计算机系统里，<span style="color:#FF0000;"> 软件和硬件在逻辑上是等效的 </span>，用软件实现一个功能的要求较低的成本，但同时也只有较低的效率，而硬件则是需要较高 的成本，但是有着较高的效率。</span>





### 3.2 冯 · 诺伊曼计算机的特点

1.计算机由五大部件组成（存储器、运算器、控制器、输入设备、输出设备）

2.指令和数据以同等地位存于存储器，可按地址寻访

3.指令和数据用二进制表示

4.指令由操作码和地址码组成

5.存储程序（指令事先以二进制的形式存于主存储器里）

<span style="color:#FF0000;"> 6.以运算器为中心 </span>（输入输出设备与存储器之间的数据传送通过运算器完成）





思考：运算器主要用于数据运算和指令的执行，但是此时它却主要用于数据的传送，那么它的运算能力不就大大下降了？



![image-20240228153951947](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240228153951947.png)



<span style="background:#33FFFF;"> 由这个例子不难看出原本采购部门存放物资的工作却由生产部门来完成，拉低了效率，这显然是不合理的 </span>





### 3.3 现代计算机的结构

![image-20240228155027692](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240228155027692.png)



<span style="font-size:1.4em;"> 现代计算机通常 <span style="background:#FFFF00;"> 以存储器为核心 </span>，这样由输入设备输入的数据就可以直接转入存储器里，运算器就可以不用传输数据，大大提高了计算效率，在大规模集成电路时期由于运算器与控制器的逻辑关系十分紧密，所以他们通常被集成在同一个芯片上，如今的 <span style="background:#33FFFF;"> CPU 就是由运算器加控制器组成 </span> </span>

![image-20240228161207211](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240228161207211.png)

这里的主机与我们生活里的主机不同，我们生活中的主机还包括风扇和硬盘

由图可以得知，主机里的存储器是指主存，而辅存（辅助存储）通常是指硬盘

比如上图的手机机身存储 128G 就是指辅存





### 3.4 小节回顾

![image-20240228161745112](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240228161745112.png)





## 4.各个硬件的工作原理

### 4.1 主存储器的硬件组成

#### 4.1.1MAR 与 MDR

![image-20240301095625206](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240301095625206.png)

` MAR`: Memory Address Register, <span style="color:#FF3333;"> 存储地址寄存器 </span>，用于存储数据的地址（取件号）



` MDR`: Memory Data Register ，<span style="color:#FF0000;"> 存储数据寄存器 </span>，用于存储数据本身（包裹本身）



<span style="background:#00FFFF;"> CPU 可以对主存储器执行 <span style="color:#FF0000;"> 写入 </span> 和 <span style="color:#FF0000;"> 读取 </span> 两种操作 </span>



#### 4.1.2.存储体

![image-20240301101055183](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240301101055183.png)



对于存储体，它由一个个存储单元组成，<span style="color:#FF0000;"> **数据在存储体内按地址存储** </span>，地址从 0 开始，每个地址对应一个存储单元，存储单元放着存储字，存储字就是二进制代码的组合，它的大小称为存储字长，一般由具体的硬件环境决定，通常是 8bit 的整数倍



**MAR 的位数**：地址的位数就反映了存储体内有多少个存储单元（这里地址由二进制表示），如果 MAR 有四位，则代表 <span style="color:#FF0000;"> 最多 </span> 有 2 <span style="vertical-align:super;"> 4 </span> 个存储单元



**MDR 的位数**：MDR 里存放的是具体的数据，数据就是一个个存储字，所以 MDR 的位数就是存储字的位数，即存储字长



存储元（拓展）：存储二进制的电子元件（电容），可以存放电荷，每个存储元可以存放 1bit，<span style="color:#FF0000;"> 一个个存储元组成了存储单元 </span>







### 4.2 运算器的基本组成

![image-20240301103647687](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240301103647687.png)

运算器由四部分组成，ACC、MQ、X 都是简单的寄存器，而 ALU 是算术逻辑单元，由复杂的电路实现，造价最高



### 4.2 控制器的基本组成

![image-20240301104206103](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240301104206103.png)





**CU** 是控制器权力的核心，**IR** 用来存放当前执行的指令（是指令本身，而不是地址），**PC** 是程序计数器，存放下一条指令的地址，有自动加一的功能，完成一条指

令首先需要在 PC 里取出指令，然后将其放入 IR 里，<span style="color:#FF0000;"> 分析指令的功能是由 CU 来完成，而不是 IR，指令放入 IR 后 CU 才可以进行分析执行 </span> <span style="color:#FF0000;">，IR 和 CU 间会相互协作 </span>，而取指令和分析指令我们都称为取指，只有执行指令才称为执行



### 4.3.计算机的工作过程

我们用高级语言写一段简单的代码

```c
int a=2,b=3,c=1,y=0;
void main(){
    y=a*b+c;
}
```



然而对于计算机而言却需要执行一系列复杂的操作



![image-20240301111137331](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240301111137331.png)

首先，CPU 里的控制器内部的 PC 单元指向第一条指令的存储地址，CPU 通过控制总线告诉主存储器执行读操作，



然后第一步 PC 将第一条指令的地址交给主存储器里的 MAR，使得 MAR 的地址为 0（第一条指令的地址）

第二步是 MAR 通过地址在存储体内得到指令本身

第三步 MAR 将指令交给 MDR，导致 MDR 值为第一条指令

第四步 MDR 将第一条指令交给控制器内的 IR（存放正在执行的指令），使得 IR 值为第一条指令

第五步 IR 与 CU 进行协作，CPU 自动将指令分为操作码和地址码，指令的操作码被送到 CU，CU 分析后发现这是“<span style="color:#FF0000;"> 取数 </span>”指令

第六步 IR 里指令的地址码被送往 MAR，使得 MAR = 5（即地址为 5 的指令，a 的值）

第七步又是 MAR 通过地址在存储体内得到指令本身

第八步 MAR 将指令交给 MDR，导致 MDR 值为地址为 5 的那条指令

第九步 MDR 通过数据总线将 a 的值交给运算器里的 ACC（操作数寄存器），即 a = 5，至此完成了取数操作







**值得注意的是在完成了一到四步取指令的操作后，PC 的值就会自动加 1，以指向下一条需要执行的指令**



![image-20240301144403023](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240301144403023.png)



接下来执行的乘法指令的取数部分基本与上述步骤相同，在进行乘法计算时，会将被乘数放在 X 这个通用寄存器里，将乘数放在 MQ 这个

乘商寄存器里，最后计算的结果会放在 ACC 寄存器里，如果乘积太大，ACC 寄存器里放不下，就会需要 MQ 辅助存储（存放计算结果的低

位）



![image-20240301145918099](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240301145918099.png)



然后是加法指令，与乘法指令不同的时被加数被放在 ACC 寄存器里，而通用寄存器 X 里放的是加数（<span style="color:#FF0000;"> 乘法里存放于 ACC 的被乘数会先读入通用寄存器 X 在参与运算，而加法里放在 ACC 寄存器里的被加数可以直接参与运算 </span>）



![image-20240301150815938](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240301150815938.png)





接下来就是 <span style="color:#FF0000; font-weight:bold;"> 存数 </span> 指令了，一系列类似的操作后使得原本放在地址为 8 的 y 值最终为 a*b+c 的值 7（CU 控制单元通过控制总线告诉主存储器要执行的是写入操作）



![image-20240301151434772](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240301151434772.png)



最后执行的就是 <span style="color:#FF0000;"> **停机** </span> 指令了，最后利用中断机制或系统调用通知操作系统终止该进程





**总结**

![image-20240301151823681](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240301151823681.png)

只有在分析完取出的指令后 CU 才会决定采用什么样的操作，在此之前的操作都是相同的



<span style="color:#FF0000; font-weight:bold;"> CPU 区分指令和数据的依据是：指令周期的不同阶段（取指令阶段、分析指令阶段、执行指令阶段、结束阶段）</span>



### 4.4 小节回顾

![image-20240301152228994](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240301152228994.png)



CU 和 ALU 的造价最高



**注意：** <span style="background:#00FFFF;"> MAR 与 MDR 在逻辑上归于主存储器里，但是现代计算机通常把 MAR 与 MDR 寄存器集成在 CPU 里，所以有时也会在 CPU 里看见 </span>

<span style="background:#00FFFF;"> MAR 与 MDR 寄存器 </span>





## 5.计算机软件

### 系统软件和应用软件

![image-20240302105111993](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240302105111993.png)

<span style="color:#FF0000; font-weight:bold;"> 应用软件 </span>：为了解决某个应用领域的问题而编制的程序，直接向用户提供服务



<span style="color:#FF0000; font-weight:bold;"> 系统软件 </span>：负责管理硬件资源，并向上层应用程序提供基础服务（操作系统、标准程序库等）



### 三种级别的语言



![image-20240302105600800](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240302105600800.png)

分别是高级语言、汇编语言、机器语言 ，而高级语言转换为计算机能懂的机器语言又有三种方式：

1.将高级语言编写的源程序先通过编译程序编译为汇编语言，再由汇编程序转换为机器语言

2.可由源程序通过编译程序直接转换为机器语言

3.通过解释程序将高级语言解释为对应的机器语言（python 就是解释型语言）



**编译程序与解释程序的区别**：编译程序只需翻译一次，而解释程序每次执行都要翻译



编译、汇编、解释程序，统称为 “<span style="color:#FF0000; font-weight:bold;"> 翻译程序 </span>”



### 软件和硬件的逻辑功能等价性

![image-20240302110036003](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240302110036003.png)

<span style="background:#00FFFF;"> 计算机系统里，<span style="color:#FF0000;"> 软件和硬件在逻辑上是等效的 </span>，用软件实现一个功能的要求较低的成本，但同时也只有较低的效率，而硬件则是需要较高 的成本，但是有着较高的效率。</span>



<span style="color:#FF0000; font-weight:bold;"> 指令集体系结构（ISA）</span>：软件和硬件之间的界面。设计计算机的 ISA，就是要定义一台计算机可以支持哪些指令，以及每条指令的作用是什么、每条指令的用法是什么（ISA 是硬件和软件之间的桥梁，它允许不同的硬件供应商提供兼容同一 ISA 的处理器，从而使软件开发者能够编写与硬件无关的代码。常见的 ISA 包括 x86、ARM、MIPS、PowerPC 等，它们在不同的计算机体系结构中得到广泛应用。）



### 小节回顾

![image-20240302110821660](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240302110821660.png)



## 6.计算机系统的多级层次结构

![image-20240301154002079](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240301154002079.png)



<span style="background:#FFFF00;"> 下层是上层的基础，上层是下层的扩展，关于计算机系统的层次结构这个问题，不同学科由不同的划分，在于视角的不同，此处主要是以编程人员与硬件设计人员的视角 </span>



一条指令可以划分为一条条“<span style="color:#FF0000; font-weight:bold;"> 微指令 </span>”





### 小节回顾

![image-20240302111251172](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240302111251172.png)



## 7.计算机系统的工作原理

### 从 c 语言源程序到可执行文件

![image-20240302112035288](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240302112035288.png)





<span style="font-weight:bold;"> 预处理器 </span>：对 c 语言中#开头的命令处理（如宏定义常量的替换#define）

<span style="font-weight:bold;"> 编译器 </span>：将源程序翻译为汇编语言

<span style="font-weight:bold;"> 汇编器 </span>：将汇编语言程序翻译为二进制机器语言（汇编后的机器语言程序又称 <span style="color:#FF0000;"> 目标模块 </span>）

<span style="font-weight:bold;"> 链接器 </span>：将多个相关的目标模块链接成完整的可执行文件



### 计算机系统的工作原理

![image-20240302112737662](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240302112737662.png)



<span style="background:#33FFFF;"> 链接完成的可执行文件被保存在硬盘这些外存里，当需要执行时会被读取到主存中，同时我们可以使用键盘、鼠标等输入设备与程序进行交互，输出的结果可以通过显示器等输出设备来显示出来 </span>



### “存储程序”工作方式

![image-20240302113314833](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240302113314833.png)



### 小节回顾

![image-20240302113510675](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240302113510675.png)





重点掌握 <span style="color:#FF0000;"> 编译器 </span>、<span style="color:#FF0000;"> 汇编器 </span>、<span style="color:#FF0000;"> 链接器 </span> 的概念即可



## 8.计算机性能指标

### 8.1 存储器的性能指标

![image-20240301202630186](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240301202630186.png)



对于存储器，<span style="color:#FF0000; font-weight:bold;"> 容量大小 </span> 就可以反映它的性能指标



### 8.2CPU 的性能指标

![image-20240301204243002](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240301204243002.png)

<span style="font-weight:bold;"> CPU 主频 </span>：CPU 内数字脉冲信号振荡的频率

<span style="font-weight:bold;"> CPI </span>：执行一条指令所需的时钟周期数

吉普森法



![image-20240301210655118](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240301210655118.png)



此例题里 CPI 是每条指令的平均值，主频分之一就是 CPU 时钟周期



![image-20240302114020753](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240302114020753.png)



<span style="font-weight:bold;"> IPS </span>：每秒执行的指令数量

<span style="font-weight:bold;"> FLOPS </span>：每秒执行多少次浮点数



在 IPS 和 FLOPS 两种指标前通常有 K、M、G、T 等数量单位以满足实际的需求

新增 P = 10 <span style="vertical-align:super; color:#FF0000;"> 3 </span> T，E = 10 <span style="vertical-align:super; color:#FF0000;"> 3 </span> P，Z = 10 <span style="vertical-align:super; color:#FF0000;"> 3 </span> E

对于 CPU 有 <span style="color:#FF0000; font-weight:bold;"> CPU 主频 </span> 和 <span style="color:#FF0000; font-weight:bold;"> CPI </span>（从微观上没有意义，以为影响因素太多）<span style="color:#FF0000; font-weight:bold;"> IPS </span>、<span style="font-weight:bold; color:#FF0000;"> FLOPS </span> 四个指标来表示 cpu 的性能





### 8.3 系统整体的性能指标

![image-20240302125403690](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240302125403690.png)

<span style="font-weight:bold;"> 数据通路带宽 </span>：数据总线一次所能并行传送信息的位数（<span style="color:#FF0000; font-weight:bold;"> 各硬件部件通过数据总线传输数据 </span>）

<span style="font-weight:bold;"> 吞吐量 </span>：系统在单位时间内处理请求的数量（<span style="color:#FF0000; font-weight:bold;"> 取决于主存的存取周期 </span>）

<span style="font-weight:bold;"> 响应时间 </span>：指从向计算机发送一个请求到系统对该请求做出回应并获得所需要的结果的等待时间（<span style="color:#FF0000; font-weight:bold;"> 通常包括 CPU 时间和等待时间 </span>）

![image-20240302130404247](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240302130404247.png)



<span style="font-size:1.2em;"> 通过一些“<span style="color:#FF0000;"> 跑分软件 </span>”进行动态测试也可测试系统整体的性能指标 </span>





![image-20240302131637344](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240302131637344.png)



主频高的 CPU 不一定快，还需要比较平均 CPI。

平均 CPI 相同，主频高的 CPU 还是不一定快，因为它可能不支持乘法指令，那么就需要运行多次加法。

基准程序（跑分软件）执行的快也不一定说明性能好，比如一台主要不是用来图像处理的计算机，使用测试显卡标准的基准程序测试的结果就不可靠。



### 8.4 小节回顾

![image-20240302132130322](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240302132130322.png)

![image-20240302132200233](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240302132200233.png)







# 第二章 数据的表示和运算

## 1.进位计数制

![image-20240302194142492](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240302194142492.png)

### 古老的计数法

![image-20240302194707411](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240302194707411.png)





**<span style="background:#3399FF;"> 基于加法思想的计数方式 </span>**







### 十进制计数法

![image-20240302195210445](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240302195210445.png)



<span style="background:#00FFFF;"> **符号反映权重，符号的位置同样反映权重** </span>



<span style="background:#00FFFF;"> **十进制的发明源于我们人类有着十根手指** </span>



![image-20240302200128196](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240302200128196.png)

计算机世界使用二进制有着以上这三个好处（逻辑门电路就是一种表示二进制信号的元器件）



<span style="color:#FF0000; font-weight:bold;"> 使用八进制和十六进制的原因时他们和二进制有着较好的对应关系，可以很方便的与二进制进行相互转换 </span>





### 任意进制转换为十进制

![image-20240302200529334](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240302200529334.png)







其他进制转换为十进制的方法就是 <span style="color:#FF0000; font-weight:bold;"> 将各个数码位上的数字乘以他在该位置上的权重，然后再相加 </span> 就可以了







### 二进制转换为八、十六进制

![image-20240302201116841](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240302201116841.png)





二进制的一位可以表示 0 或 1 两种情况，那么三个二进制位就可以表示 2x2x2 = 8 种情况，同理四个二进制数就可以表示十六种情况



也就是说 <span style="color:#FF0000; font-weight:bold;"> 三个二进制数可以表示一个八进制数，四个二进制数可以表示一个十六进制数 </span>



八进制与十六进制转换为二进制无非就是上述过程的逆向操作



<span style="background:#00FFFF;"> 转换过程中还要注意 <span style="font-weight:bold; color:#FF0000;"> 补位 </span>，对于整数部分我们通常在高位补位，小数部分在低位补位（因为凑不到三个或四个的整数倍）</span>



### 各种进制的常见书写方式

![image-20240302202039570](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240302202039570.png)

### 十进制转换为任意进制

![image-20240302202857555](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240302202857555.png)



对于一个十进制数，我们想要把他转换完其他进制，每次对这个数进行 <span style="color:#FF0000; font-weight:bold;"> 除基 </span>，然后 <span style="color:#FF0000; font-weight:bold;"> 取余 </span>（比如转换为二进制，就每次除二，那么他的第一个余数就是二进制数的 <span style="color:#FF0000; font-weight:bold;"> 最低位 </span>）



![image-20240302203434494](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240302203434494.png)

对于十进制数的小数部分（即上图的蓝色部分），我们每次对小数部分进行 <span style="color:#FF0000; font-weight:bold;"> 乘基 </span>，然后 <span style="color:#FF0000; font-weight:bold;"> 取整数部分 </span>，剩下的小数部分继续乘基（还是比如转换位二进制，就将小数部分每次乘二，得到的第一个数的整数部分就是二进制小数的 <span style="color:#FF0000; font-weight:bold;"> 最高位 </span>，将小数部分继续乘基，循环以上步骤）



<span style="background:#00FFFF;"> 对于十进制的 0.3，无法用有限的二进制数来表时 </span>



这种方法我们称为 <span style="color:#FF0000; font-weight:bold;"> 乘基取整法 </span>



![image-20240302204745593](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240302204745593.png)



在明确二进制的各个位置的权重时我们也可以使用 <span style="color:#FF0000; font-weight:bold;"> 拼凑法 </span> 来进行进制转换





### 真值和机器数

![image-20240302205143194](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240302205143194.png)

<span style="font-weight:bold;"> 真值 </span>：符合人类习惯的数字

<span style="font-weight:bold;"> 机器数 </span>：数字实际存到机器里的形式，正负号需要被“数字化”







### 小节回顾

![image-20240302205356651](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240302205356651.png)





## 2.BCD 码







<span style="font-size:1.9em; color:#FF0000; font-weight:bold;"> 不考 </span>





## 3.定点数的表示

![image-20240302211604283](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240302211604283.png)



<span style="font-weight:bold;"> 定点数：小数点的位置固定，要么在最后面，要么在最前面（如 0.23，也属于定点数）</span>

浮点数：小数点的位置不固定，会浮动（比如使用科学计数法的数）







![image-20240302212406528](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240302212406528.png)



### 3.1 无符号数的表示

![image-20240302212859400](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240302212859400.png)



<span style="font-weight:bold;"> 无符号数 </span>：整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的绝对值



无符号数的表示范围首先需要一个字长是多少的前提，n 位的无符号数的表示范围：0 ~ 2 <span style="vertical-align:super;"> n </span>-1



<span style="background:#00FFFF;"> 通常只有无符号整数，而没有无符号小数 </span>



### 3.2 有符号数的定点表示

 ![image-20240303093452104](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240303093452104.png)



定点小数的数值部分 <span style="color:#FF0000; font-weight:bold;"> 也称 “尾数”</span>





#### 原码

![image-20240303094529044](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240303094529044.png)



<span style="color:#FF0000; font-weight:bold;"> 原码 </span>：用尾数表示真值的绝对值，符号位 “0/1”对应 "正/负"（<span style="font-weight:bold; color:#FF0000;"> 0 表示的是正 </span>）



<span style="color:#000000; background:#FFFF00;"> 如果机器字长位 n+1 位，则尾数占 n 位，对于没有涉及到的高位，在指明机器字长的情况下，应该为高位补上 0，若未指明，可以不补 </span>



【x】<span style="vertical-align:sub;"> 原 </span> = 1.1100000 的值是-0.11（二进制）而不是 1.11



![image-20240303095948490](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240303095948490.png)





<span style="font-weight:bold;"> 这里假设机器字长为 n+1 位，原码整数的表示范围如上图所示，理论上源码一共能表示 2 <span style="vertical-align:super;"> n+1 </span> 种不同的状态，就应该能表示 2 <span style="vertical-align:super;"> n+1 </span> 个不同的数，但实际上由于真值 0 有 <span style="color:#FF0000;">+0 和-0 </span> 两种形式，它们对应的是同一个真值 0，所以实际上一共只能表示 2 <span style="vertical-align:super;"> n+1 </span>-1 个数 </span>



注意：n 位机器字长，那么就能表示 2 <span style="vertical-align:super;"> n </span> 个不同的状态，但是表示范围（不考虑负值）最大就应该是 2 <span style="vertical-align:super;"> n </span>-1，<span style="color:#FF0000; font-weight:bold;"> 因为表示的数是从 0 开始的 </span>



对于原码小数的表示范围：2 <span style="vertical-align:super;">-1 </span>+2 <span style="vertical-align:super;">-2 </span>+...+2 <span style="vertical-align:super;"> n </span> = 1-2 <span style="vertical-align:super;">-n </span> 的原因是这是一个等比数列，公比是 2 <span style="vertical-align:super;">-1 </span>，首项也是 2 <span style="vertical-align:super;">-1 </span>，那么根据前 n 项和的公式

<span style="font-weight:bold; background:#FFFF00;"> S <span style="vertical-align:sub;"> n </span> = a <span style="vertical-align:sub;"> 1 </span>*（1-q <span style="vertical-align:super;"> n </span>）/1-q </span>

计算结果就是：1-2 <span style="vertical-align:super;">-n </span>



<span style="color:#FF0000; font-weight:bold;"> 二进制小数的第一位权重是 2 <span style="vertical-align:super;">-1 </span> 而不是 2 <span style="vertical-align:super;"> 0 </span> </span>





#### 反码

![image-20240303102822560](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240303102822560.png)



<span style="font-weight:bold; color:#FF0000;"> 反码 </span>：若符号位为 0，则反码与原码相同，<span style="color:#FF0000;"> 若符号位为 1，则数值位全部取反 </span>，反码与原码有着一一对应的关系，所以他们的 <span style="background:#FFFF00;"> 表示范围也是相同的 </span>，事实上，"反码" 只是 "原码" 转变为 “补码”的一个中间状态，计算机硬件不会直接使用反码进行运算，所以 <span style="background:#FFFF00;"> 反码实际上并没有什么用处 </span>（真值 0 也同样存在+0 和-0）







#### 补码

![image-20240303110230179](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240303110230179.png)



<span style="color:#FF0000; font-weight:bold;"> 补码 </span>：正数的补码 = 原码

​            负数的补码 = 反码末尾加 1 <span style="color:#FF0000;">（要进位）</span>

  

<span style="color:#FF0000; font-weight:bold;"> 注意：</span> <span style="font-weight:bold;"> 补码的真值 0 只有一种表示形式 </span>（这就是补码在表示范围上多出一个数的原因）

​           规定：<span style="color:#FF0000;">【x】<span style="vertical-align:sub;"> 补 </span> = 1，0000000 表示 x =-2 <span style="vertical-align:super;"> 7 </span> </span>

​                      <span style="color:#FF0000;">【x】<span style="vertical-align:sub;"> 补 </span> = 1.0000000 表示 x =-1 </span> 

​           <span style="background:#FFFF00;"> 所以补码在负数上就相较原码和反码的表示范围在整数上多了一个 <span style="color:#FF0000;">-2 <span style="vertical-align:super;"> n </span> </span>，小数上多了一个 <span style="color:#FF0000;">-1 </span> </span>

​           <span style="background:#FFFF00;">  所以相同字长下补码的表示范围就与原码反码不同 </span>

​        

​        （表示范围的比较符号两侧是最大最小值，而不是数量，所以对于补码负数的表示范围是大于等于 <span style="color:#FF0000;">-1 </span>）





补码转换回原码的方式很简单（正数的原码补码相同，这里指负数）: <span style="color:#FF0000; font-weight:bold;"> 只需要将尾数取反，末尾加 1 </span>（逆向操作）







#### 移码

![image-20240303111711057](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240303111711057.png)





<span style="color:#FF0000; font-weight:bold;"> 移码：</span> 在补码的基础上将符号位取反就可以得到移码了



<span style="color:#FF0000; font-weight:bold;"> 注意：</span> <span style="background:#FFFF00;"> 移码只能用于表示整数 </span>

​         

​            移码与补码有着一一对应的关系，所以移码的真值 0 同样只有一种表示形式，相较于原码和反码，移码的表示范围同样比它们多        了一个-2 <span style="vertical-align:super;"> n </span>（<span style="color:#FF0000;"> 相同字长时，且要注意移码不表示小数 </span>）







![image-20240303112455404](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240303112455404.png)





<span style="font-weight:bold;"> 计算机使用移码的原因 </span>：当把移码看为无符号数时，可以很方便的比较大小，计算机视角与人不同，对于移码，计算机在比较大小时，只需要 <span style="color:#FF0000; font-weight:bold;"> 从左到右观察两个数谁先出现了 1 </span>（在补码，反码和原码中 1 都是表示负数）



<span style="font-weight:bold;"> 移码全 0 时真值最小，移码全 1 时真值最大，所以很方便计算机硬件比较大小 </span>



![image-20240303113136562](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240303113136562.png)



由于补码和移码的真值 0 只有一种表示方式，所以补码和移码可以多表示一个负数







![image-20240303114235235](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240303114235235.png)





熟练各种码之间的转换，对于正数原码、反码、补码的值相同，负数的反码在原码的基础上，将数值部分取反，负数的补码是在反码的基础上再末位加 1，移码只能表示整数，是将补码的符号位改变后得到的，补码变回原码只需要再取反加一就可以了





<span style="color:#FF0000; font-weight:bold;"> 技巧：</span> 若已知【x】<span style="vertical-align:sub;"> 补 </span> 求【-x】<span style="vertical-align:sub;"> 补 </span> <span style="color:#FF0000;"> 只需要将符号位、数值位全部取反，末尾加 1 就可以了 </span>



### 3.3 知识回顾

![image-20240303114951907](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240303114951907.png)



<span style="font-weight:bold;"> 对于定点整数我们默认小数点隐含在数值部分末尾出 </span>

<span style="font-weight:bold;"> 对于定点小数我们默认小数点隐含在符号位后面 </span>









## 4.各种码的作用

### 加减运算

![image-20240304222441817](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240304222441817.png)







计算机中在对于原码表示的有符号数进行加减时就需要考虑到 <span style="color:#FF0000; font-weight:bold;"> 符号 </span>



在对于一个原码表示的负数进行加法时，计算机通常将它转换为正数，然后将运算符号改为 <span style="font-weight:bold; color:#FF0000;"> 减号 </span>



所以一个 ALU（逻辑运算单元）就既需要一个加法器，有需要一个减法器，加法器用硬件好实现，但是减法器工艺较复杂，成本较高，于是就有人想到 <span style="color:#FF0000; font-weight:bold;"> 用加法来代替减法 </span>



#### 用加法代替减法

![image-20240304223824033](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240304223824033.png)







如上图对于一个在 10 点的时钟，我们想要将它调到 7 点，可以直接逆时针拨动三点，也可以顺时针拨动 9 点，都可以达到调到 7 点的目的

我们可以将逆时针看为减法 10-7 = 3，将顺时针看为加法 10+9 = 19，由于时钟只有 12 个点数，所以 19 模 12 = 7





<span style="font-weight:bold;"> 这两种方法的结果相同的原因是-3 模 12 = 9，9 模 12 也等于 9，所以挪动-3 点和挪动 9 点的结果时一样的 </span>



#### 模运算的性质

![image-20240304230047190](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240304230047190.png)



<span style="color:#FF0000; font-weight:bold;"> 模运算需满足公式： x = qm  +  r （r 为余数），m 是模数，其中 q 要求是一个整数（可负），r 需要在 0 到模之间 </span>



-3 mod 12 =（-1）*12 + 9                                        9 mod 12 = 0 * 12 +9



<span style="font-weight:bold;"> 模 12 就是把所有整数分成了余数为 0~11 的 12 类数，所有模 12 余数相同的数，都是同一类数，都是等价的 </span>



<span style="font-weight:bold; color:#0000CC;"> 补数：</span> 对于模同一个数，余数相同的数里，满足 <span style="font-weight:bold; color:#FF0000;"> 二者绝对值之和 = 模 </span> 的两个数我们称他们互为 <span style="font-weight:bold; color:#FF0000;"> 补数 </span>（显然这两个数都要小于模数）



<span style="font-weight:bold;"> 找到负数的补数，就可以用正数的加法来等价代替减法，因为比如 10-3 即 10+（-3）在 mod 12 的条件下等价于 10+9、10+21 </span>



<span style="font-weight:bold;"> 快速找到负数补数的方法 </span>：<span style="background:#FFFF00;"> 模 - 负数的绝对值 = 负数的补数 </span>



（我的感悟：上例中，对于模 12 余数为 9 的同类数里，在 12 这个上限中只有-3 和+9 两个数是这个条件下同类数的 <span style="color:#FF0000; font-weight:bold;"> 根本 </span>，其他所有同类数无论正负都是这两个数的变形，示例里说只要能找到负数的补数就可以用正数的加法来替代减法，原本我以为对于-15，21，33 这种绝对值已经大于模数的数找不到它们的补数，仔细一想，比如在时钟只有 12 点这个限制下，<span style="color:#FF0000; font-weight:bold;"> 所有绝对值大于 12 的数都是它们这一类数里的互为补数的两个数的变形 </span>，也就是说-15 是理论上的数，在限制下它和-3 是等价的，逆时针转动 15 点不就相当于逆时针转动 3 点吗，那么-15 的补数就是 9、21，33...）







![image-20240304235623617](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240304235623617.png)





对于一个机器字长为 8bit 的计算机，它最大可表示 2 <span style="vertical-align:super;"> 8 </span> 个数，超过这个范围就无法表示了，也就是说 <span style="color:#FF0000; font-weight:bold;"> 这台计算机天然执行了模 2 <span style="vertical-align:super;"> 8 </span> 的操作 </span>



那么对于计算中的减法，我们就可以利用模运算的性质找到减法中负数的补数（也就是补码），来代替原本的负数，是减法变为加法，然后计算结果天然模 2 <span style="vertical-align:super;"> 8 </span>, 就可以得到我们想要的计算结果了



<span style="font-weight:bold; color:#FF0000; background:#FFFF00;">补数就是补码的原始定义</span>



<span style="font-weight:bold;"> 所以补码的一个作用就是——让减法操作转变为加法操作，节省硬件成本 </span>





![image-20240305001043973](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240305001043973.png)

<span style="font-weight:bold;"> 符号位参与运算 </span>









#### 其它码的作用

![image-20240305001325016](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240305001325016.png)

<span style="font-weight:bold;"> 移码由于它的绝对值递增和真值的递增有相同的方向，所以很方便计算机来比较大小 </span>





<span style="font-weight:bold;"> 反码只是原码转变为补码的中间状态 </span>



<span style="font-weight:bold;"> 原码符合我们对二进制的理解，如果只使用原码进行运算，就会需要一个额外的减法运算器，所以计算机将原码转换为补码来用加法代替减法 </span>

















## 5.数字电路基础知识（逻辑门电路）



<span style="font-weight:bold; color:#FF0000;"> 科普 </span>：**逻辑闸** 或 **逻辑门** 是 [集成电路](https://zh.wikipedia.org/wiki/集成電路) 的基本组件。简单逻辑门可由 [晶体管](https://zh.wikipedia.org/wiki/晶体管) 组成。这些晶体管的组合可以使代表两种信号的高低 [电平](https://zh.wikipedia.org/wiki/电平) 在通过它们之后产生高电平或者低电平的 [信号](https://zh.wikipedia.org/wiki/信号)。高、低电平可以分别代表逻辑上的“真”（T；true）与“假”（F；false）或 [二进制](https://zh.wikipedia.org/wiki/二进制) 的 1 和 0，从而实现逻辑运算。常见的逻辑门包括与闸，或门，非闸，异或闸（也称异或）。

逻辑门是组成数字系统的基本结构，通常组合使用运算更复杂的逻辑。一些厂商通过组合逻辑门生产实用、小型、集成的产品，如 [可编程逻辑器件](https://zh.wikipedia.org/wiki/可程式邏輯裝置)。





### 5.1 算术运算和逻辑运算

![image-20240305233827412](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240305233827412.png)



<span style="font-weight:bold;"> 算术运算：</span> 就是对数字进行运算，包括基本算术运算（加、减、乘、除），复合算术运算（幂次方等），事实上幂次方这种复合运算也是有基本运算叠加得到（一次次乘法）





<span style="font-weight:bold;"> 逻辑运算：</span> 对逻辑值进行运算，只有两个真（1）和假（0），它也包括基本逻辑运算（与、或、非）和复合逻辑运算（异或等），这种复合运算同样是由基本运算叠加的





### 5.2 基本逻辑运算：与

![image-20240305234558794](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240305234558794.png)







<span style="font-weight:bold;"> 与 </span> 的门电路如图所示，左为国标画法，右为国际常用画法，与运算时，<span style="font-weight:bold; color:#FF0000;"> 只有当前后都为真值时，结果才为真 </span>







### 5.3 基本逻辑运算：或

![image-20240305234922903](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240305234922903.png)



<span style="font-weight:bold;"> 或 </span> 的门电路如图所示，左为国标画法，右为国际常用画法，与运算时，<span style="font-weight:bold; color:#FF0000;"> 只要前后有一个真值时，结果就为真 </span>，或运算的门电路在不同教材里的图像可能有很多种，但是有 <span style="color:#FF0000; font-weight:bold;"> 一个共同的特点就是输入端的那条边为弧线 </span>





### 5.4 基本逻辑运算：非

![image-20240305235714252](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240305235714252.png)





<span style="font-weight:bold;"> 非 </span> 运算也就是取反，输入 0，就得到 1，输入 1，就得到 0。非的门电路也称为“<span style="font-weight:bold; color:#FF0000;"> 非门 </span>”，它的特点就是在输出端有一个小圆圈（也可以时输入端）。







### 5.5 复合逻辑运算：与非

![image-20240306000545050](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240306000545050.png)



<span style="font-weight:bold;"> 与非 </span> 运算就是先进行与运算再进行非运算，<span style="color:#FF0000; font-weight:bold;"> 相当于与运算的取反 </span> ，它的门电路由与和非简化而成，就是在与门电路的输出端加一个 <span style="font-weight:bold; color:#FF0000;"> 小圆圈 </span>

由于是与运算的取反，所以它有着和与运算相反的真值





### 5.6 复合逻辑运算：或非

![image-20240306001501144](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240306001501144.png)

<span style="font-weight:bold;"> 或非 </span> 运算就是先进行或运算再进行非运算，<span style="color:#FF0000; font-weight:bold;"> 相当于或运算的取反 </span> ，它的门电路由或和非简化而成，就是在或门电路的输出端加一个 <span style="font-weight:bold; color:#FF0000;"> 小圆圈 </span>

由于是或运算的取反，所以它有着和或运算 <span style="font-weight:bold;"> 相反 </span> 的真值





### 5.7 复合逻辑运算：异或

![image-20240306002640983](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240306002640983.png)



<span style="font-weight:bold;"> 异或 </span> 运算就是对于相同的输入值，输出假，只有在输入的值相异的时候才输出真，它的实现电路较为繁琐，但是，对于使用者来说，我们只关心此部件的功能，而电路内部的实现细节被设计者隐藏了，对外只暴露输入输出功能的引脚，这种思想在编程中也是通用的，我们称为 “<span style="font-weight:bold; color:#FF0000;"> 封装思想 </span>”



注意表达式





### 5.8 复合逻辑运算：同或

![image-20240306003312094](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240306003312094.png)

<span style="font-weight:bold;"> 同或 </span> 相当于异或运算取反（有时也会翻译为 “<span style="color:#FF0000;"> 异或非 </span> 门”），只有在输入的两个值具有相同的真值时才为 1。







### 5.9 逻辑门电路基础总结

![image-20240306003723254](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240306003723254.png)







![image-20240306004142848](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240306004142848.png)



<span style="font-weight:bold;"> 就是说 n 个比特的二进制数连续进行异或运算，如果所有二进制数里 1 的个数为奇数，那么异或的结果就是 1，若有偶数个，那么异或结果为 0 </span>





### 5.10 补充一：门电路的变形画法

![image-20240306004649418](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240306004649418.png)

<span style="font-weight:bold;"> 有的时候门电路的输入端会不止两个，这种多输入的变形门电路原理都是一样的 </span>







### 5.11 补充二：逻辑运算的优先级

![image-20240306005442145](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240306005442145.png)

<span style="color:#FF0000; font-weight:bold;"> 优先级：非 > 与 > 或 </span>

<span style="color:#FF0000; font-weight:bold;"> 注：反演率就是德摩根率（和的逆等于逆的积）</span>



我们学习这些逻辑运算公式（也就是学习数学），对于现实生活也是十分有用的，如上例，使用运算公式对表达式进行了一个简化，在现

实里也可以通用简化实际的电路设计，这样就可以极大节约成本



### 5.12 拓展 芯片制程

![image-20240306010039337](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240306010039337.png)





## 6.数字电路基础知识（加法器）

### 6.1 加法器的基本功能

![image-20240306142323765](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240306142323765.png)

![image-20240306143011291](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240306143011291.png)





计算机里的正在进行加法的两个二进制数，加法是在每一位与每一位之间进行的，对应的两位称为 <span style="font-weight:bold; color:#FF0000;"> 本位 </span>，计算时除了考虑计算的本位外，还要考虑来自更低位的 <span style="font-weight:bold; color:#FF0000;"> 进位 </span>，两个本位加上进位的和称为 <span style="color:#FF0000; font-weight:bold;"> 本位和 </span> 



输入的三个数里（两个本位和和一个进位），如果有奇数个 1，则输出 1，否则输出 0（<span style="font-weight:bold; color:#FF0000;"> 恰好可用异或逻辑门电路来实现 </span>）

进位：当两个本位都为 1 或两个本位里有一个 1 且来自低位的进位是 1，这时会向高位进 1







### 6.2 一位全加器

![image-20240306144155570](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240306144155570.png)





将本位和的逻辑门电路与进位电路融合就可以得到 <span style="font-weight:bold; color:#FF0000;"> 一位全加器 </span>



n 位累加运算就可以拆分为一个个一位加法运算





### 6.3n bit 加法器

![image-20240306144434584](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240306144434584.png)







![image-20240306145655589](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240306145655589.png)

<span style="font-weight:bold;"> 高位的运算需要等待低位的进位信息稳定后并传达，所以会花费一段时间 </span>





“<span style="background:#FFFF00;"> 串行进行的并行加法器 </span>”：前面的串行是指，进位信息以串行传递，后者的并行指的是可以支持 n bit 并行输入







### 6.4 并行进位的并行加法器

![image-20240306150215669](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240306150215669.png)





<span style="font-weight:bold;"> 进位信息都是同时产生的，几乎没有延迟，更 fast！</span>



<span style="font-weight:bold;"> 下节细说 </span>



### 6.5 带标志位的加法器

![image-20240306151404211](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240306151404211.png)



由于带符号数与无符号数的进位 <span style="font-weight:bold;"> 逻辑不同 </span>，所以分别为他们设计了判断是否溢出的标志位



![image-20240306151924782](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240306151924782.png)



### 6.6 小节回顾



![image-20240306152006186](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240306152006186.png)





## 7.数字电路基础知识（并行电路加法器）

![image-20240307003347432](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240307003347432.png)





被加数、加数的各位我们一开始就知道，所以我们通过一步步推理，完全可以直接推出向更高位的进数



对于 C <span style="vertical-align:sub;"> i </span> 表达式的理解：

​                                     所谓进位，无非是两种情况：A 加数与被加数都为 1，相加为 0，进一位

​                                                                                       B 加数与被加数只有 1 个 1，且低位进位 1，刚好相加为 0，进一位

​                                     加数与被加数的相与（一位）：当只有一个 1 时，相与结果为 0，只有在都为 1 时，结果为 1，<span style="font-weight:bold; color:#FF0000;"> 这个用来代表情况 A </span>





​                                     加数与被加数的异或（一位）：异或结果还要和低位的进位相与，结果为一的情况是加数与被加数有一个 1，且低位                              



​                                                                                           进位 1，<span style="font-weight:bold; color:#FF0000;"> 这个代表情况 B </span>

​                                     





<span style="font-weight:bold;"> C <span style="vertical-align:sub;"> i </span> 表达式刚好巧妙的涵盖了进位的所有情况 </span>







![image-20240307010409639](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240307010409639.png)







如上式：各个进位的逻辑表达式可以得到并展开，不难发现，进位表达式所需的所有元素我们在计算一开始就可以的到，所以就可以将这些信息提前输入到全加器里，直接得到各位的进位。



由于一直展开会使电路越来越复杂，所以可以只使用四个全加器，写入这个运算逻辑，组成一个四位加四位的加法器









## 8.数字电路基础知识（多路选择器和三态门）



### 8.1 多路选择器（MUX）

![image-20240307011129240](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240307011129240.png)









<span style="font-weight:bold;"> 多路选择器用于在多个输入数据中，选择其中一个数据通过 MUX，其他全部拦截 </span>



<span style="background:#FFFF00;"> 控制信号在电路图里一般为 <span style="font-weight:bold; color:#FF0000;"> 虚线 </span>，数字信号一般为 <span style="font-weight:bold; color:#FF0000;"> 实线 </span> </span>



<span style="font-weight:bold;"> m 满足图中的公式是因为，log <span style="vertical-align:sub;"> 2 </span> k 个比特就足以表达 k 个输入，比如 8 个输入，我们只需要三位的二进制数就可以全部覆盖 </span>



![image-20240307011920648](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240307011920648.png)





### 8.2 三态门

![image-20240307012223469](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240307012223469.png)



<span style="font-weight:bold;"> 作用是根据控制信号决定是否让输入的数据通过 </span>



三态门的控制信号只需 1bit



三态门是一种重要的总线接口，三态对应那三态？

<span style="background:#FFFF00;"> 三态：高电平、低电平、高阻态 </span>





高阻态：即输出电阻无穷大，相当于断路







![image-20240307012607304](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240307012607304.png)







三态门一段加上 “小圆圈”的作用是增加非运算，<span style="color:#FF0000;"> 相当于给输出的结果取反 </span>



与非门在电路图里可以说一模一样，但有个唯一的区别：<span style="color:#FF0000; font-style:italic; font-weight:bold; background:#FFFF00;">“非门”没有控制信号 </span>



![image-20240307013026443](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240307013026443.png)







<span style="background:#FFFF00;"> 预留一个控制信号时，则信号位数就应该 <span style="font-weight:bold; color:#FF0000;"> 至少 </span> 是 log <span style="vertical-align:sub;"> 2 </span> k +1 </span>









## 9.算术逻辑单元 ALU

### 9.1ALU 的作用

![image-20240307155648090](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240307155648090.png)





运算器负责对数字进行处理，如：加减乘除，而 <span style="font-weight:bold;"> ALU 就是运算器的核心 </span>，事实上无论是减法、乘法还是除法，都是由加法来实现的，所以 ALU 的核心是 <span style="font-weight:bold; color:#FF0000;"> 加法器 </span>





### 9.2ALU 的功能

![image-20240307160413307](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240307160413307.png)

ALU 的功能有 <span style="font-weight:bold;"> 算术运算 </span>、<span style="font-weight:bold;"> 逻辑运算 </span>，还包括一些其他的运算：<span style="font-weight:bold;"> 求补码、直送 </span> 等。



求补码：将原码转换为补码

直送：怎么进去，怎么出来，就是把数据直接通过 ALU



由控制器发来的 <span style="color:#FF0000; font-weight:bold;"> 控制信号的位数由 ALU 的功能种类决定 </span>，比如要是支持十一种功能，那么就至少要四位才能满足，因为三 <span style="font-weight:bold;"> 位二进制码只能表示 8 种不同情况 </span>，所以至少需要四位，满足以上公式







### 9.3ALU 的实现原理（了解即可）

![image-20240307161103866](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240307161103866.png)





<span style="font-weight:bold;"> 可以把一个个不同功能的电路全部放入 <span style="color:#FF0000;">多路选择器 </span>里，使用控制信号来控制哪条线路畅通，从而实现相应的功能，将内部细节隐藏并封装后就得到了我们想要的 ALU 逻辑运算单元 </span>



### 9.4ALU 图示

![image-20240307161555406](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240307161555406.png)



<span style="font-weight:bold; background:#FFFFFF; color:#FF0000;"> ALU 的运算数、运算结果位数就决定了计算机的机器字长 </span>



对于标志位，在标志位输出后会存入 PSW 程序状态字寄存器，方便计算机检测运算结果

有的计算机系统把 PSW 寄存器称为 <span style="font-weight:bold; color:#FF0000;">“标志寄存器 FR”</span>



Cin：进位输入信号

Cout：进位输出信号







### 真题

![image-20240307162102287](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240307162102287.png)





### 小节回顾

![image-20240307162622648](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240307162622648.png)





## 10.定点数的移位运算

### 10.1原码的算数移位



![image-20240308184854927](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240308184854927.png)





移位：通过改变各个数码位与小数点的相对位置，从而可以改变数码位的位权。  可以使用移位运算实现<span style="color:#FF0000;">乘法、除法</span>

上例是十进制，二进制也是一样









#### 原码右移

![image-20240308185952131](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240308185952131.png)





<span style="font-weight:bold;">原码的算术移位</span>：符号位不移动，仅对数值位进行移位。



右移：高位补0，低位舍弃（因为机器字长是固定的），如果要舍弃的位是0，则相当于除了一个2（二进制），如果不是0，则会<span style="font-weight:bold; color:#FF0000;">丢失精度</span>（因为含有数值的低位被舍弃）





#### 原码左移

![image-20240308191130519](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240308191130519.png)





与原码右移刚好相反，是高位舍弃，低位补0，如果要舍弃的高位是0，则相当于乘了一个2，如果舍弃的不是0，则会出现<span style="font-weight:bold; color:#FF0000;">严重误差</span>（如上例中当左移三位时，应该是十进制的 - 160 ，但是由于机器字长是八位，符号位占了一位，剩下的7位，最大只能表示 -127，所以导致高位舍弃了一个不为0的数值位）









定点小数也是同理，左移相当于乘以个2，右移相当于除了一个2，关于高位舍弃还是低位舍弃和整数也是完全一致的（<span style="font-weight:bold;">因为无论是小数还是整数的符号位都在左边</span>）





### 10.2反码的算数移位

![image-20240308192634492](C:\Users\86136\AppData\Roaming\Typora\typora-user-images\image-20240308192634492.png)





<span style="font-weight:bold;">对于反码来说，由于正数的原码反码完全相同，所以移位的原理也相同，而对于负数，由于反码的数值位与原码相反，所以负数反码的移位规则就是在原码的基础上将补的 <span style="color:#FF0000;">“0”</span>改为补<span style="color:#FF0000;"> “1”</span></span>





### 10.3移码的算数移位

![image-20240308235602581](https://cdn.jsdelivr.net/gh/rzpwhx/markdown@main/202403082356695.png)
